local config
--points loaded from configuration
local points = {}
--all points generated by config loading, with subpoints receiving individual entries.
local individualPoints = {}
local pointTypes = {}
if not os.loadAPI("priority") then error("Could not load priority API") end
if not os.loadAPI("configuration") then error("Could not load configuration API") end

--loadConfig function replaced with simple configuration.load("control.config") call later on in file.

local function loadPoints()
	if fs.exists("points") and fs.isDir("points") then
		for _, name in pairs(fs.list("points")) do
			local env, err = configuration.load((fs.combine("points", name)))
			if env then
				pointTypes[name] = env
			else
				return false, err
			end
		end
	else
		return false, "no points folder"
	end
	return true
end

local function setupPoints()
	for i, pInfo in ipairs(config.points) do
		if pointTypes[pInfo.type] then
			--create point.
			setfenv(pointTypes[pInfo.type].new, setmetatable(getfenv(pointTypes[pInfo.type].new), {__index = _G}))
			points[#points + 1] = pointTypes[pInfo.type].new(pInfo)
			if points[#points].subpoints then
				for i, sub in ipairs(points[#points].subpoints) do
					table.insert(individualPoints, sub)
				end
			else
				table.insert(individualPoints, points[#points])
			end
		end
	end
end

local function loadState()
	if fs.exists("control.state") then
		local handle = io.open("control.state", "r")
		if handle then
			local savedState = textutils.unserialize(handle:read("*a"))
			handle:close()
			for i = 1, #savedState do
				if points[i].subpoints then
					for j, sub in ipairs(points[i].subpoints) do
						sub:restoreState(savedState[i][sub.name])
					end
				else
					points[i]:restoreState(savedState[i])
				end
			end
		else
			return false, "could not open saved state file"
		end
	else
		return false, "no saved state"
	end
	return true
end

local function saveState()
	local state = {}
	for i, point in ipairs(points) do
		if point.subpoints then
			local subState = {}
			for j, sub in ipairs(point.subpoints) do
				subState[sub.name] = sub:saveState()
			end
			state[i] = subState
		else
			state[i] = points[i]:saveState()
		end
	end
	local handle = io.open("control.state", "w")
	if handle then
		handle:write(textutils.serialize(state))
		handle:close()
	else
		return false, "could not open state file to write"
	end
end

do
	local success, err
	config, err = configuration.load("control.config")
	if not config then error(err) end
	success, err = loadPoints()
	if not success then error(err) end
	setupPoints()
	loadState()
end

--to be called in parallel, ticks all points.
local function tickPoints()
	local time = os.startTimer(0.2)
	while true do
		local event = {os.pullEvent()}
		if event[1] == "timer" and event[2] == time then
			local changed, changes = false, {}
			for i, point in ipairs(individualPoints) do
				point:tick()
				changed = changed or point.changed
				table.insert(changes, i)
				point.changed = false
			end
			if changed then
				os.queueEvent("cov", changes)
				saveState()
			end
			time = os.startTimer(0.2)
		end
	end
end

local function makeMeta(point)
	local pmeta = {
		__index = function(t, k)
			if k == "value" then
				return point.value
			elseif k == "priority" then
				return point.priority
			else
				return nil
			end
		end,
		__newindex = function(t, k, v)
			if k == "value" then
				point:setValue(v)
			elseif k == "priority" then
				point:onCommand({value = point.value, priority = v})
			end
		end,
	}
	return pmeta
end

local pointsEnv = {[config.name] = {}}
for i = 1, #points do
	if points[i].subpoints then
		--do subpoint stuff
		pointsEnv[config.name][points[i].name] = {}
		for j, sub in ipairs(points[i].subpoints) do
			--add all subpoints from the table to this point.
			pointsEnv[config.name][points[i].name][sub.name] = setmetatable({}, makeMeta(sub))
		end
		setmetatable(pointsEnv[config.name][points[i].name], {__newindex = function(t, k, v) end})
	else
		pointsEnv[config.name][points[i].name] = setmetatable({}, makeMeta(points[i]))
	end
end

local function runPrograms()
	local env = {points = pointsEnv}
	setmetatable(env, {__index = _G})
	local programs = {}
	if fs.exists("programs") and fs.isDir("programs") then
		for _, name in pairs(fs.list("programs")) do
			local file = fs.combine("programs", name)
			local fn, err = loadfile(file)
			if fn then
				setfenv(fn, env)
				table.insert(programs, fn)
			end
		end
	else
		while true do
			os.pullEvent("terminate")
		end
	end
	parallel.waitForAll(unpack(programs))
end

if config.master then
	for _, side in ipairs(rs.getSides()) do
		if peripheral.getType(side) == "modem" then
			rednet.open(side)
		end
	end
end

local function send(id, message)
	if term.current then
		rednet.send(id, message, "base-mate")
	else
		rednet.send(id, message)
	end
end

local function doCommunication()
	if config.master then
		send(config.master, "connect_panel")
		local timeout = os.startTimer(5)
		local id, message
		while true do
			local event = {os.pullEvent()}
			if event[1] == "rednet_message" and event[2] == config.master then
				id, message = event[2], event[3]
				break
			elseif event[1] == "timer" and event[2] == timeout then
				break
			end
		end
		if id and message and message == "ok" then
			while true do
				local event = {os.pullEvent()}
				if event[1] == "rednet_message" and event[2] == config.master and type(event[3]) == "table" then
					if event[3].type == "q_point_list" then
						local pointList = {type = "point_list", points = {}}
						for i = 1, #points do
							local point = {
								name = config.name.."."..points[i].name,
								value = points[i].value,
								priority = points[i].priority,
							}
							table.insert(pointList.points, point)
						end
						send(config.master, pointList)
					elseif event[3].type == "q_value" then
						for i, point in ipairs(individualPoints) do
							local testName = config.name.."."..(point.super and point.super.."." or "")..point.name
							if testName == event[3].point then
								send(config.master, point.value)
								break
							end
						end
					elseif event[3].type == "command" then
						for i, point in ipairs(individualPoints) do
							local testName = config.name.."."..(point.super and point.super.."." or "")..point.name
							if testName == event[3].point then
								point:onCommand(event[3].command)
								break
							end
						end
					elseif event[3].type == "heartbeat" then
						send(config.master, {type = "ack"})
					end
				elseif event[1] == "cov" then
					for i = 1, #event[2] do
						local point = individualPoints[event[2][i]]
						local change = {
							type = "cov",
							point = config.name.."."..(point.super and point.super.."." or "")..point.name,
							value = point.value,
							priority = point.priority,
						}
						send(config.master, change)
					end
				end
			end
		else
			while true do
				os.pullEvent("terminate")
			end
		end
	else
		while true do
			os.pullEvent("terminate")
		end
	end
end

parallel.waitForAny(tickPoints, runPrograms, doCommunication)
