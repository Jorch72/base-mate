local config
local points = {}
local pointTypes = {}
if not os.loadAPI("priority") then error("Could not load priority API") end
if not os.loadAPI("configuration") then error("Could not load configuration API") end

--loadConfig function replaced with simple configuration.load("control.config") call later on in file.

local function loadPoints()
	if fs.exists("points") and fs.isDir("points") then
		for _, name in pairs(fs.list("points")) do
			local env, err = configuration.load((fs.combine("points", name)))
			if env then
				pointTypes[name] = env
			else
				return false, err
			end
		end
	else
		return false, "no points folder"
	end
	return true
end

local function setupPoints()
	for i, pInfo in ipairs(config.points) do
		if pointTypes[pInfo.type] then
			--point type exists, see if point has subpoints
			if pInfo.subpoints then
				for j, subInfo in ipairs(pInfo.points) do
					if pointTypes[pInfo.type][subInfo.type] then
						setfenv(pointTypes[pInfo.type][subInfo.type], setmetatable(getfenv(pointTypes[pInfo.type][subInfo.type]), {__index = _G}))
						points[#points + 1] = pointTypes[pInfo.type][subInfo.type](pInfo, subInfo)
						--subpoint key tells the pointsEnv portion of things that this should be a subpoint.
						points[#points].subpoint = pInfo.name
					end
				end
			else
				--create single point.
				setfenv(pointTypes[pInfo.type].new, setmetatable(getfenv(pointTypes[pInfo.type].new), {__index = _G}))
				points[#points + 1] = pointTypes[pInfo.type].new(pInfo)
			end
		end
	end
end

local function loadState()
	if fs.exists("control.state") then
		local handle = io.open("control.state", "r")
		if handle then
			local savedState = textutils.unserialize(handle:read("*a"))
			handle:close()
			for i = 1, #savedState do
				points[i]:restoreState(savedState[i])
			end
		else
			return false, "could not open saved state file"
		end
	else
		return false, "no saved state"
	end
	return true
end

local function saveState()
	local state = {}
	for i = 1, #points do
		state[i] = points[i]:saveState()
	end
	local handle = io.open("control.state", "w")
	if handle then
		handle:write(textutils.serialize(state))
		handle:close()
	else
		return false, "could not open state file to write"
	end
end

do
	local success, err
	config, err = configuration.load("control.config")
	if not config then error(err) end
	success, err = loadPoints()
	if not success then error(err) end
	setupPoints()
	loadState()
end

--to be called in parallel, ticks all points.
local function tickPoints()
	local time = os.startTimer(0.2)
	while true do
		local event = {os.pullEvent()}
		if event[1] == "timer" and event[2] == time then
			local changed, changes = false, {}
			for i = 1, #points do
				points[i]:tick()
				changed = changed or points[i].changed
				table.insert(changes, i)
				points[i].changed = false
			end
			if changed then
				os.queueEvent("cov", changes)
				saveState()
			end
			time = os.startTimer(0.2)
		end
	end
end

local function makeMeta(point)
	local pmeta = {
		__index = function(t, k)
			if k == "value" then
				return point.value
			else
				return nil
			end
		end,
		__newindex = function(t, k, v)
			if k == "value" then
				point:setValue(v)
			end
		end,
	}
	return pmeta
end

local pointsEnv = {[config.name] = {}}
for i = 1, #points do
	if points[i].subpoint then
		--do subpoint stuff
		if not pointsEnv[config.name][points[i].subpoint] then
			pointsEnv[config.name][points[i].subpoint] = {}
			local submeta = {
				__newindex = function(t, k, v) end,
			},
			setmetatable(pointsEnv[config.name][points[i].subpoint], submeta)
		end
		local pTable = {}
		setmetatable(pTable, makeMeta(points[i]))
		rawset(pointsEnv[config.name][points[i].subpoint], points[i].name, pTable)
	else
		pointsEnv[config.name][points[i].name] = {}
		setmetatable(pointsEnv[config.name][points[i].name], makeMeta(points[i]))
	end
end

local function runPrograms()
	local env = {points = pointsEnv}
	setmetatable(env, {__index = _G})
	local programs = {}
	if fs.exists("programs") and fs.isDir("programs") then
		for _, name in pairs(fs.list("programs")) do
			local file = fs.combine("programs", name)
			local fn, err = loadfile(file)
			if fn then
				setfenv(fn, env)
				table.insert(programs, fn)
			end
		end
	else
		while true do
			os.pullEvent("terminate")
		end
	end
	parallel.waitForAll(unpack(programs))
end

if config.master then
	for _, side in ipairs(rs.getSides()) do
		if peripheral.getType(side) == "modem" then
			rednet.open(side)
		end
	end
end

local function send(id, message)
	if term.current then
		rednet.send(id, message, "base-mate")
	else
		rednet.send(id, message)
	end
end

local function doCommunication()
	if config.master then
		send(config.master, "connect_panel")
		local timeout = os.startTimer(5)
		local id, message
		while true do
			local event = {os.pullEvent()}
			if event[1] == "rednet_message" and event[2] == config.master then
				id, message = event[2], event[3]
				break
			elseif event[1] == "timer" and event[2] == timeout then
				break
			end
		end
		if id and message and message == "ok" then
			while true do
				local event = {os.pullEvent()}
				if event[1] == "rednet_message" and event[2] == config.master and type(event[3]) == "table" then
					if event[3].type == "q_point_list" then
						local pointList = {type = "point_list", points = {}}
						for i = 1, #points do
							local point = {
								name = config.name.."."..points[i].name,
								value = points[i].value,
								priority = points[i].priority,
							}
							table.insert(pointList.points, point)
						end
						send(config.master, pointList)
					elseif event[3].type == "q_value" then
						for i = 1, #points do
							if config.name.."."..points[i].name == event[3].point then
								send(config.master, points[i].value)
								break
							end
						end
					elseif event[3].type == "command" then
						for i = 1, #points do
							if config.name.."."..points[i].name == event[3].point then
								points[i]:onCommand(event[3].command)
								break
							end
						end
					elseif event[3].type == "heartbeat" then
						send(config.master, {type = "ack"})
					end
				elseif event[1] == "cov" then
					for i = 1, #event[2] do
						local change = {
							type = "cov",
							point = config.name.."."..points[event[2][i]].name,
							value = points[event[2][i]].value,
							priority = points[event[2][i]].priority,
						}
						send(config.master, change)
					end
				end
			end
		else
			while true do
				os.pullEvent("terminate")
			end
		end
	else
		while true do
			os.pullEvent("terminate")
		end
	end
end

parallel.waitForAny(tickPoints, runPrograms, doCommunication)
